"""
|‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢| 
‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù         |           ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù

                          GNU GENERAL PUBLIC LICENSE
                            Version 3, 29 June 2007
                            
        Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
            Everyone is permitted to ùó∞ùóºùóΩùòÜ ùóÆùóªùó± ùó±ùó∂ùòÄùòÅùóøùó∂ùóØùòÇùòÅùó≤ verbatim copies
                of this license document, ùóØùòÇùòÅ ùó∞ùóµùóÆùóªùó¥ùó∂ùóªùó¥ ùó∂ùòÅ ùó∂ùòÄ ùóªùóºùòÅ ùóÆùóπùóπùóºùòÑùó≤ùó±.
                        ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù,
                        Telegram Music player userbot 
                has been licensed under GNU General Public License
            ùêÇùê®ùê©ùê≤ùê´ùê¢ùê†ùê°ùê≠ (ùêÇ) ùüêùüéùüêùüè ùóõùòÜùóΩùó≤ùó©ùóºùó∂ùó±ùó¶ùóºùòÇùóπ | ùóõùòÜùóΩùó≤ùó©ùóºùó∂ùó±ùóüùóÆùóØ | ùóõùòÜùóΩùó≤ùó©ùóºùó∂ùó±ùòÄ
‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù         |           ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù
|‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢|        
"""
from x·¥á Ä·¥èÍú∞…™ ü·¥á·¥õÍú±.butts import MIB,SIB
from ·¥ò·¥ú Ä…¢·¥á_·¥ç·¥á·¥Ñ ú·¥Ä…¥…™Íú±·¥ç import * 
from ·¥ç·¥úÍú±…™·¥Ñ_·¥Ñ·¥è…¥·¥õ·¥á…¥·¥õ import *
from x·¥á Ä·¥èÍú∞…™ ü·¥á·¥õÍú± import *
from  ü…™ ô Ä·¥Ä Ä è import *
from  ú·¥è·¥ç·¥á import *


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
heroku_api = "https://api.heroku.com"
Heroku = heroku3.from_key(HEROKU_API_KEY)
lg_id = LOGGER_ID



async def restart(client, XS: XeroSpeak):
    if HEROKU_APP_NAME and HEROKU_API_KEY:
        try:
            Heroku
        except BaseException:
            return await XS.replay_text("`HEROKU_API_KEY` is wrong. Re-Check in config vars.")
        await XS.replay_text(f"‚úÖ **Restarted Dynos** \n**Type** /xero **after 1 minute to check if I am working !**")
        app = Heroku.apps()[HEROKU_APP_NAME]
        app.restart()
    else:
        os.system("python3 hypefile.py")


@Client.on_message(
filters.group
& Xero_Music_Admins
& ~filters.edited
& Known_User
& Xero_Singer
& filters.command("restart", prefixes="/"))
async def re(client, XS: XeroSpeak):
    event = await XS.reply_text( "Restarting Dynos ...")
    if HEROKU_API_KEY:
        await restart(event)
    else:
        await event.edit("Please Set Your `HEROKU_API_KEY` to restart ”º…õ Ä÷Ö’º÷Ö…®…ñ")


@Client.on_message(
filters.group
& Xero_Music_Admins
& ~filters.edited
& Known_User
& Xero_Singer
& filters.command("shutdown", prefixes="/"))
async def down(client, XS: XeroSpeak):
    event = await XS.reply_text( "`Turing Off Heroku Dynos...`")
    await asyncio.sleep(2)
    await event.edit("**[ ‚ö†Ô∏è ]** \n**”º…õ Ä÷Ö’º÷Ö…®…ñ Dynos is now turned off. Manually turn it on to start again.**")
    if HEROKU_APP_NAME is not None:
        HEROKU_APP_NAME.process_formation()["worker"].scale(0)
    else:
        sys.exit(0)
@Client.on_message(
filters.group
& Xero_Music_Admins
& ~filters.edited
& Known_User
& Xero_Singer
& filters.command("usage", prefixes="/"))
async def dyno_usage(client, XS: XeroSpeak):
    event = await XS.reply_text( "`Processing...`")
    useragent = (
        "Mozilla/5.0 (Linux; Android 10; SM-G975F) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/80.0.3987.149 Mobile Safari/537.36"
    )
    user_id = Heroku.account().id
    headers = {
        "User-Agent": useragent,
        "Authorization": f"Bearer {HEROKU_API_KEY}",
        "Accept": "application/vnd.heroku+json; version=3.account-quotas",
    }
    path = "/accounts/" + user_id + "/actions/get-quota"
    r = requests.get(heroku_api + path, headers=headers)
    if r.status_code != 200:
        return await event.edit(
            "`Error: something bad happened`\n\n" f">.`{r.reason}`\n"
        )
    result = r.json()
    quota = result["account_quota"]
    quota_used = result["quota_used"]

    """ - Used - """
    remaining_quota = quota - quota_used
    percentage = math.floor(remaining_quota / quota * 100)
    minutes_remaining = remaining_quota / 60
    hours = math.floor(minutes_remaining / 60)
    minutes = math.floor(minutes_remaining % 60)

    """ - Current - """
    App = result["apps"]
    try:
        App[0]["quota_used"]
    except IndexError:
        AppQuotaUsed = 0
        AppPercentage = 0
    else:
        AppQuotaUsed = App[0]["quota_used"] / 60
        AppPercentage = math.floor(App[0]["quota_used"] * 100 / quota)
    AppHours = math.floor(AppQuotaUsed / 60)
    AppMinutes = math.floor(AppQuotaUsed % 60)

    await asyncio.sleep(1.5)

    return await event.edit(
        "‚ö° **Dyno Usage** ‚ö°:\n\n"
        f" ‚û† __Dyno usage for__ ‚Ä¢ **{HEROKU_APP_NAME}** ‚Ä¢ :\n"
        f"     ‚òÖ  `{AppHours}`**h**  `{AppMinutes}`**m**  "
        f"**|**  `{AppPercentage}`**%**"
        "\n\n"
        " ‚û† __Dyno hours remaining this month__ :\n"
        f"     ‚òÖ  `{hours}`**h**  `{minutes}`**m**  "
        f"**|**  `{percentage}`**%**"
        f"\n\n**Owner :** {OWNER_USERNAME}"
    )