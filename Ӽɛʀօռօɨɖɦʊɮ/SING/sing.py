"""‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù         |           ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù
|‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢| 
                          GNU GENERAL PUBLIC LICENSE
                            Version 3, 29 June 2007
                            
        Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
            Everyone is permitted to ùó∞ùóºùóΩùòÜ ùóÆùóªùó± ùó±ùó∂ùòÄùòÅùóøùó∂ùóØùòÇùòÅùó≤ verbatim copies
                of this license document, ùóØùòÇùòÅ ùó∞ùóµùóÆùóªùó¥ùó∂ùóªùó¥ ùó∂ùòÅ ùó∂ùòÄ ùóªùóºùòÅ ùóÆùóπùóπùóºùòÑùó≤ùó±.

                        ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù,
                        Telegram Music player userbot 
                has been licensed under GNU General Public License
            ùêÇùê®ùê©ùê≤ùê´ùê¢ùê†ùê°ùê≠ (ùêÇ) ùüêùüéùüêùüè ùóõùòÜùóΩùó≤ùó©ùóºùó∂ùó±ùó¶ùóºùòÇùóπ | ùóõùòÜùóΩùó≤ùó©ùóºùó∂ùó±ùóüùóÆùóØ | ùóõùòÜùóΩùó≤ùó©ùóºùó∂ùó±ùòÄ
|‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢|        
‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù         |           ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù"""
from ”º…õ Ä÷Ö’º÷Ö…®…ñ ç ä÷Ü…®∆à import *
from ∆à ä÷Ü»∂÷Ö ç_ Ñ…® ü»∂…õ Ä÷Ü import *
from …ñ÷Ö÷Ö ç_ Ä÷Ö÷Ö ç import *
from «ü ä»∂÷Ö_÷Ñ ä Ä…¢…õ Ä import *
from  ü…®…Æ Ä«ü Ä è_ Ä÷Ö÷Ö ç import *
'‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù    ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢|‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢    ‚áú‚ä∑¬∞‚Ä¢‚ô™   ü¶ã ”º…õ Ä÷Ö’º÷Ö…®…ñü¶ã   ‚ô™‚Ä¢¬∞‚ä∂‚áù'



# @”º…õ Ä÷Ö’º÷Ö…®…ñ.on_message(
# xerofil.group
# & ~xerofil.edited
# & xeronoid_chat_check
# & xerofil.command("play") | xerofil.audio)
# async def play_track(client, xemsg: xeromsg):
#     group_call = xep.group_call
#     if xemsg.audio:
#         if xemsg.audio.duration > (MAX_MIN * 60):
#             cprint('üéß ùó®ùòÄùó≤ùóø ùóÆùòÄùó∏ùó≤ùó± ùòÅùóº ùóΩùóπùóÆùòÜ ùóÆùòÇùó±ùó∂ùóº ùóØùòÇùòÅ ùóÆùòÇùó±ùó∂ùóº ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª ùóªùóºùòÅ ùó∫ùó≤ùòÅ', 'yellow', attrs=['reverse'])
#             xeronoid_throw = await xemsg.reply_animation(
#             animation=xerolink,
#             caption=f"{XEXO}üöÄüî• ŒâYPŒ£ V”®ID LŒõB üî•üöÄ\n\nüéß ùôéùô§ùôßùôßùôÆ ùôñùô™ùôôùôûùô§ ùô¨ùôùùôûùôòùôù ùôôùô™ùôßùôñùô©ùôûùô§ùô£ ùô°ùô§ùô£ùôúùôöùôß ùô©ùôùùôñùô£ {str(MAX_MIN)} ùó∫ùó∂ùóª ùòÑùóºùóª'ùòÅ ùóØùó≤ ùóÆùòÇùòÅùóºùó∫ùóÆùòÅùó∂ùó∞ùóÆùóπùóπùòÜ ùóÆùó±ùó±ùó≤ùó± ùòÅùóº ùòÖùó≤ùóøùóºùóªùóºùó∂ùó± ùó∫ùòÇùòÄùó∂ùó∞ ùóπùó∂ùòÄùòÅ."
#             )
#             await delay_play_messages((xeronoid_throw,), PLAY_REMOVER)
#             return
#         m_audio = xemsg
#     elif xemsg.reply_to_message and xemsg.reply_to_message.audio:
#         m_audio = xemsg.reply_to_message
#         if m_audio.audio.duration > (MAX_HOUR * 60 * 60):
#             cprint('üéß ùó®ùòÄùó≤ùóø ùóÆùòÄùó∏ùó≤ùó± ùòÅùóº ùóΩùóπùóÆùòÜ ùóÆùòÇùó±ùó∂ùóº ùóØùòÇùòÅ ùóÆùòÇùó±ùó∂ùóº ùó±ùòÇùóøùóÆùòÅùó∂ùóºùóª ùóªùóºùòÅ ùó∫ùó≤ùòÅ', 'yellow', attrs=['reverse'])
#             xeronoid_throw = await xemsg.reply_animation(
#             animation=xerolink,
#             caption=f"{XEXO}üöÄüî• ŒâYPŒ£ V”®ID LŒõB üî•üöÄ\n\nüéß ùôéùô§ùôßùôßùôÆ ùôñùô™ùôôùôûùô§ ùô¨ùôùùôûùôòùôù ùôôùô™ùôßùôñùô©ùôûùô§ùô£ ùô°ùô§ùô£ùôúùôöùôß ùô©ùôùùôñùô£ {str(MAX_HOUR)} ùóµùóºùòÇùóøùòÄ ùòÑùóºùóª'ùòÅ ùóØùó≤ ùóÆùó±ùó±ùó≤ùó± ùòÅùóº ùòÖùó≤ùóøùóºùóªùóºùó∂ùó± ùó∫ùòÇùòÄùó∂ùó∞ ùóπùó∂ùòÄùòÅ."
#             )
#             await delay_play_messages((xeronoid_throw,), PLAY_REMOVER)
#             return
#     else:
#         await xep.xeronoid_show_playlist()
#         await xemsg.delete()
#         return
#     if group_call and group_call[-1].audio.file_unique_id \
#             == m_audio.audio.file_unique_id:
#         xeronoid_throw = await xemsg.reply_animation(
#         animation=xerolink,
#         caption=f"{XEXO}üöÄüî• ŒâYPŒ£ V”®ID LŒõB üî•üöÄ\n\nüéß ùôàùô™ùô®ùôûùôò ùôñùô°ùôßùôöùôñùôôùôÆ ùôñùôôùôôùôöùôô. ùôéùô†ùôûùô•ùô•ùôûùô£ùôú!"
#         )
#         await delay_play_messages((xeronoid_throw, xemsg), PLAY_REMOVER)
#         return
#     group_call.append(m_audio)
#     if len(group_call) == 1:
#         cprint('üéß ùó®ùòÄùó≤ùóø ùóÆùòÄùó∏ùó≤ùó± ùòÅùóº ùóΩùóπùóÆùòÜ ùóÆùòÇùó±ùó∂ùóº', 'yellow', attrs=['reverse'])
#         m_status = await xemsg.reply_animation(
#         animation=xerolink,
#         caption=f"{XEXO}üöÄüî• ŒâYPŒ£ V”®ID LŒõB üî•üöÄ\n\nüéß ùóóùóºùòÑùóªùóπùóºùóÆùó±ùó∂ùóªùó¥ ùóÆùóªùó± ùòÅùóøùóÆùóªùòÄùó∞ùóºùó±ùó∂ùóªùó¥..."
#         )
#         await xeronoid_music_dl_handler(group_call[0])
#         group_call.input_filename = os.path.join(
#             client.workdir,
#             xeronoid_dl_dir,
#             f"{XEXO}üöÄüî• ŒâYPŒ£ V”®ID LŒõB üî•üöÄ\n\nüéß {group_call[0].audio.file_unique_id}.raw"
#             )
#         await xep.xeronoid_begin_clock()
#         await m_status.delete()
#         print(f"{XEXO}üöÄüî• ŒâYPŒ£ V”®ID LŒõB üî•üöÄ\n\nüéß ùó´ùó≤ùóøùóºùóªùóºùó∂ùó± ùó∂ùòÄ ùóªùóºùòÅ ùóΩùóπùóÆùòÜùó∂ùóªùó¥: {group_call[0].audio.title}" + f"\nùó∂ùóª ùòÅùóµùó≤ ùó¥ùóøùóºùòÇùóΩ `{CHAT_ID}'s` ùô´ùô§ùôûùôòùôö ùôòùôùùôñùô©'")
#     await xep.xeronoid_show_playlist()
#     for track in group_call[:2]:
#         await xeronoid_music_dl_handler(track)
#     if not xemsg.audio:
#         await xemsg.delete()
        
        
@”º…õ Ä÷Ö’º÷Ö…®…ñ.on_message(
xerofil.group
& ~xerofil.edited
& xeronoid_chat_check
& xerofil.command("play") | xerofil.audio)
async def play_track(client, xemsg: xeromsg):
    group_call = xep.group_call
    playlist_temp = xep.playlist_temp
    # check audio
    if xemsg.audio:
        if xemsg.audio.duration > (MAX_MIN * 60):
            reply = await xemsg.reply_text(
                f"audio which duration longer than "
                f"{str(MAX_MIN)} min won't be automatically "
                "added to playlist_temp"
            )
            await delay_play_messages((reply,), PLAY_REMOVER)
            return
        m_audio = xemsg
    elif xemsg.reply_to_message and xemsg.reply_to_message.audio:
        m_audio = xemsg.reply_to_message
        if m_audio.audio.duration > (MAX_HOUR * 60 * 60):
            reply = await xemsg.reply_text(
                f"audio which duration longer than "
                f"{str(MAX_HOUR)} hours won't be added to playlist_temp"
            )
            await delay_play_messages((reply,), PLAY_REMOVER)
            return
    else:
        await xep.send_playlist()
        await xemsg.delete()
        return
    # check already added
    if playlist_temp and playlist_temp[-1].audio.file_unique_id \
            == m_audio.audio.file_unique_id:
        reply = await xemsg.reply_text(f"already added")
        await delay_play_messages((reply, xemsg), PLAY_REMOVER)
        return
    # add to playlist_temp
    playlist_temp.append(m_audio)
    if len(playlist_temp) == 1:
        m_status = await xemsg.reply_text(
            f" downloading and transcoding..."
        )
        await xeronoid_music_dl_handler(playlist_temp[0])
        group_call.input_filename = os.path.join(
            client.workdir,
            xeronoid_dl_dir,
            f"{playlist_temp[0].audio.file_unique_id}.raw"
        )
        await xep.xeronoid_begin_clock()
        await m_status.delete()
        print(f"- START PLAYING: {playlist_temp[0].audio.title}")
    await xep.send_playlist()
    for track in playlist_temp[:2]:
        await xeronoid_music_dl_handler(track)
    if not xemsg.audio:
        await xemsg.delete()